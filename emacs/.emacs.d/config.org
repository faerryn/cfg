#+TITLE: Faerryn's Emacs Config
#+STARTUP: indent overview

Welcome to my humble parish of the Church of Emacs.
* Prologue
This section contains essential components necessary for the rest of
my config to work.
** Lexical Binding
[[info:elisp#Lexical Binding][Lexical Binding]] encapsulates the scoping of variables to their
context. This can make bugs easier to catch and improve performance.
#+begin_src emacs-lisp
  ;;; config.el -*- lexical-binding: t; -*-
#+end_src
** Package Manager
Straight.el is a declarative package manager for Emacs.
#+begin_src emacs-lisp
  (custom-set-variables
   '(straight-check-for-modifications nil)
   '(straight-disable-autoloads t)
   '(straight-use-symlinks t)
   '(straight-vc-git-default-clone-depth 1))
  (let ((dest (expand-file-name "straight/repos/straight.el/" user-emacs-directory))
        (repo "https://github.com/raxod502/straight.el.git"))
    (unless (file-directory-p dest)
      (call-process "git" nil nil nil
                    "clone"
                    "--depth" (number-to-string straight-vc-git-default-clone-depth)
                    repo
                    dest))
    (require 'straight (expand-file-name "straight.el" dest))
    (with-temp-buffer
      (insert-file-contents (expand-file-name "bootstrap.el" dest))
      (eval-region (search-forward "(require 'straight)")
                   (point-max))))
#+end_src
** Garbage Collector
GCMH is an intelligent garbage collection scheduler for Emacs.
#+begin_src emacs-lisp
  (straight-use-package 'gcmh)
  (require 'gcmh)
  (add-hook 'emacs-startup-hook #'gcmh-mode)
#+end_src
** Custom Symbols
Switches to and ensures the scratch buffer.
#+begin_src emacs-lisp
  (defun fearryn/scratch ()
    "Display buffer `*scratch*' in the selected window, regenerating it as necessary."
    (interactive)
    (if-let ((scratch (get-buffer "*scratch*")))
        (switch-to-buffer scratch)
      (let ((scratch (generate-new-buffer "*scratch*")))
        (with-current-buffer scratch
          (insert initial-scratch-message)
          (lisp-interaction-mode))
        (switch-to-buffer scratch))))
#+end_src

I need a hook that runs before the minibuffer opens.
#+begin_src emacs-lisp
  (defvar faerryn/before-minibuffer-hook nil
    "Normal hook run just before entry to minibuffer")
  (defun faerryn/run-before-minibuffer-hooks (&rest ignored)
    (run-hooks 'faerryn/before-minibuffer-hook))
  (advice-add #'read-from-minibuffer :before #'faerryn/run-before-minibuffer-hooks)
  (advice-add #'read-no-blanks-input :before #'faerryn/run-before-minibuffer-hooks)
  (advice-add #'read-string :before #'faerryn/run-before-minibuffer-hooks)
#+end_src

* User Interface
Blinging out Emacs since 2021.
** Declutter Widgets
Decluttering Emacs of frivolous things like menus and scroll bars.
#+begin_src emacs-lisp
  (custom-set-variables
   '(inhibit-startup-screen t)
   '(use-dialog-box nil))
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
#+end_src
** Line Numbers
Line numbers are crucial to understand where you are in a document.
#+begin_src emacs-lisp
  (custom-set-variables '(display-line-numbers-type t))
  (global-display-line-numbers-mode +1)
#+end_src
** Minibuffer Completion
The minibuffer is the empty space under the modeline. It often
features tab-to-complete functionality.
*** Consult
Consult provides a collection of useful functions that make use of minibuffer completion.
#+begin_src emacs-lisp
  (straight-use-package 'consult)
  (autoload 'consult-completion-in-region "consult"
    "Prompt for completion of region in the minibuffer if non-unique.")
  (advice-add 'completion-in-region :override #'consult-completion-in-region)
#+end_src
*** Marginalia
Marginalia provides extra information in the "margins" during minibuffer completion.
#+begin_src emacs-lisp
  (straight-use-package 'marginalia)
  (require 'marginalia)
  (marginalia-mode +1)
#+end_src
*** Orderless
Orderless provides a smarter, more usable sorting and searching for
minibuffer completion.
#+begin_src emacs-lisp
  (straight-use-package 'orderless)
  (require 'orderless)
  (custom-set-variables
   '(completion-styles '(orderless))
   '(completion-category-defaults nil)
   '(completion-category-overrides '((file (styles partial-completion)))))
#+end_src
*** Vertico
Vertico provices a performant and extensible minibuffer-based completion framework.

#+begin_src emacs-lisp
  (straight-use-package
   `(vertico :files ,(cons "extensions/*.el" straight-default-files-directive)))
  (require 'vertico)
  (vertico-mode +1)
#+end_src

This enables mouse support.
#+begin_src emacs-lisp
  (require 'vertico-mouse)
  (vertico-mouse-mode +1)
#+end_src
** Modeline
The modeline is the the bar the displays, among other things, a
buffer's name and major mode.

Emacs' default modeline is weird. Doom Emacs provides us with an
aesthetic alternative.
#+begin_src emacs-lisp
  (straight-use-package 'doom-modeline)
  (autoload 'doom-modeline-mode "doom-modeline" "Toggle doom-modeline on or off." t)
  (add-hook 'emacs-startup-hook #'doom-modeline-mode)
#+end_src

Show the time and battery level on the modeline.
#+begin_src emacs-lisp
  (custom-set-variables
   '(battery-mode-line-format "%p%%")
   '(display-time-default-load-average nil)
   '(display-time-format "%T")
   '(display-time-interval 1))
  (display-time-mode +1)
  (display-battery-mode +1)
#+end_src
** Rainbow
#+begin_src emacs-lisp
  (straight-use-package 'rainbow-mode)
  (custom-set-variables
   '(rainbow-ansi-colors nil)
   '(rainbow-html-colors nil)
   '(rainbow-latex-colors nil)
   '(rainbow-r-colors nil)
   '(rainbow-x-colors nil))
  (require 'rainbow-mode)
  (add-hook 'conf-mode-hook #'rainbow-mode)
  (add-hook 'text-mode-hook #'rainbow-mode)
  (add-hook 'prog-mode-hook #'rainbow-mode)
#+end_src
** Show Paren
This highlights matching quotes, parentheses, brackets, etc...
#+begin_src emacs-lisp
  (show-paren-mode +1)
#+end_src
** Tab Bar
The tab bar manages different buffers and window configuration in
different tabs. This feature seems stolen from Vim.
#+begin_src emacs-lisp
  (custom-set-variables
   '(tab-bar-close-button nil)
   '(tab-bar-new-button nil))
  (tab-bar-mode +1)
#+end_src
** Theme
Emacs' default theme is blindingly bright. Doom Emacs (once again)
provides an aesthetic alternative.
#+begin_src emacs-lisp
  (straight-use-package 'doom-themes)
  (require 'doom-themes)
  (load-theme 'doom-one t)
#+end_src
** Treesitter
Treesitter is a asbtract syntax generator stolen from Neovim. Using
performant and accurate AST generation, fast and correct highlighting
is possible for compatible languages.
#+begin_src emacs-lisp
  (straight-use-package 'tree-sitter)
  (straight-use-package 'tree-sitter-langs)
  (require 'tree-sitter)
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode +1)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode)
#+end_src
** Truncate Lines
Line wrap is weird and confusing. Truncated lines are elephants.
#+begin_src emacs-lisp
  (custom-set-variables '(truncate-lines t))
#+end_src
** Visual Aids
Editing is as much reading as writing. This section focuses on
improving the reading experience.
** Whitespace
Display normally transparent characters. Catch the trailing spaces.
#+begin_src emacs-lisp
  (custom-set-variables '(whitespace-style '(face tabs trailing tab-mark)))
  (global-whitespace-mode +1)
#+end_src
* Text Editing
Emacs is a text-editor, after all.
** Custom Keys
Key bindings are the bread and butter of Emacs. It goes to reason that
you can define your own!
#+begin_src emacs-lisp
  (define-key (current-global-map) (kbd "C-c x") #'fixup-whitespace)
#+end_src
** LSP Client
[[https://microsoft.github.io/language-server-protocol][Language server protocol]] is a protocol invovling a server generating
intelligent code assistance for an abitrary editor that supports the
protocol. It brings IDE-grade completion and linting to any
LSP-capable editor.

Eglot is a LSP client written in Elisp, bringing the power of an IDE
to Emacs.
#+begin_src emacs-lisp
  (straight-use-package 'eglot)
  (custom-set-variables '(eglot-autoshutdown t))
  (autoload 'eglot "eglot"
    "Manage a project with a Language Server Protocol (LSP) server." t)
  (with-eval-after-load "eglot"
    (define-key eglot-mode-map (kbd "C-c a") #'eglot-code-actions)
    (define-key eglot-mode-map (kbd "C-c r") #'eglot-rename)
    (defun faerryn/eglot-setup-fosa ()
      (if (eglot-managed-p)
          (add-hook 'before-save-hook #'eglot-format)
        (remove-hook 'before-save-hook #'eglot-format)))
    (add-hook 'eglot-managed-mode-hook #'faerryn/eglot-setup-fosa))
#+end_src

Set `rust-analyzer' as the default rust-mode LSP server.
#+begin_src emacs-lisp
  (with-eval-after-load "eglot"
    (add-to-list 'eglot-server-programs '(rust-mode . ("rust-analyzer"))))
#+end_src
** Electric Pairs
Automagically close quotes, parentheses, brackets, etc...
#+begin_src emacs-lisp
  (electric-pair-mode +1)
#+end_src
** Indentation
Indent with 2 spaces.
#+begin_src emacs-lisp
  (custom-set-variables
   '(indent-tabs-mode nil)
   '(tab-width 2))
#+end_src
** Tab-to-Complete
Bring the tab-to-complete experience to Emacs!
#+begin_src emacs-lisp
  (custom-set-variables '(tab-always-indent 'complete))
#+end_src
* Major Modes
Major modes represent filetypes in Emacs.
** C/C++
Bringing tab-to-complete to C/C++, which is useful when combined with
LSP servers that provide completion.
#+begin_src emacs-lisp
  (with-eval-after-load "cc-mode"
    (advice-add 'c-indent-command :override #'indent-for-tab-command))
#+end_src
** Dired
Dired is the file browser in Emacs.

This prettifies dired's file listing.
#+begin_src emacs-lisp
  (custom-set-variables '(dired-listing-switches "-AFghvX --group-directories-first"))
#+end_src

This loads up extra features for dired.
#+begin_src emacs-lisp
  (custom-set-variables '(dired-x-hands-off-my-keys nil))
  (require 'dired-x)
#+end_src
** Org
Emacs' Org mode has superpowers.
#+begin_src emacs-lisp
  (custom-set-variables
   '(org-catch-invisible-edits 'smart)
   '(org-clock-sound t))
#+end_src
** Pdf-View
The Portable Document Format is the most widespread method of
publishing paginated, formatted text.
#+begin_src emacs-lisp
  (straight-use-package 'pdf-tools)
  (autoload 'pdf-view-mode "pdf-tools" "Major mode in PDF buffers." t)
  (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdf-view-mode))
#+end_src
** Rust
[[https://www.rust-lang.org][Rust]] is a programming language with focus on performance and memory
safety. It boasts a builtin project and dependency manager, and
delightfully concise syntax.
#+begin_src emacs-lisp
  (straight-use-package 'rust-mode)
  (autoload 'rust-mode "rust-mode"
    "Major mode for Rust code." t)
  (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
#+end_src
** Zig
[[https://ziglang.org][Zig]] is an ambitious programming language with zero cost duck-typing
and concise code. It boasts an incredibly powerful type system and
featureful compile-time code execution.
#+begin_src emacs-lisp
  (straight-use-package 'zig-mode)
  (custom-set-variables '(zig-format-on-save nil))
  (autoload 'zig-mode "zig-mode"
    "A major mode for the Zig programming language." t)
  (add-to-list 'auto-mode-alist '("\\.zig\\'" . zig-mode))
#+end_src
* Xorg Integration
Xorg is the classic Linux display server.
** Terminal Emulator
Emacs can run in a text terminal through `emacs -nw'.

Text terminals sometimes support the mouse, and emacs can support text
terminals supporting the mouse.
#+begin_src emacs-lisp
  (add-hook 'tty-setup-hook #'xterm-mouse-mode)
#+end_src

Emacs in an X11 terminal emulator cannot access the clipboard by
default. This package detects a suitable CLI clipboard tool (such as
the eponymous `xclip') to integrate into Emacs.
#+begin_src emacs-lisp
  (straight-use-package 'xclip)
  (autoload 'xclip-mode "xclip"
    "Minor mode to use the `xclip' program to copy&paste." t)
  (defun faerryn/safe-xclip-mode ()
    (ignore-errors
      (xclip-mode +1)))
  (add-hook 'tty-setup-hook #'faerryn/safe-xclip-mode)
#+end_src
** Window Manager
An X11 window manager is what powers most Linux desktops.

EXWM is a window manager written in Elisp. Lots of hacks are used to
customize the behavior of EXWM.
#+begin_src emacs-lisp
  (straight-use-package 'exwm)
  (autoload 'exwm-init "exwm"
    "Initialize EXWM." t)
  (with-eval-after-load "exwm"
    (defun faerryn/exwm-toggle-input ()
      "Toggle EXWM buffers between `line' and `char' mode."
      (interactive)
      (when-let ((id (exwm--buffer->id (current-buffer))))
        (pcase exwm--input-mode
          ('line-mode (exwm-input-release-keyboard id))
          ('char-mode (exwm-input-grab-keyboard id)))))
    (defcustom faerryn/exwm-input-global-keys nil
      "Key bindings that are allowed in EXWM char-mode"
      :type '(repeat key-sequence)
      :set (lambda (symbol value)
             (set symbol value)
             (setq exwm-input--global-keys value)
             (exwm-input--update-global-prefix-keys)))
    (custom-set-variables
     '(exwm-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "C-q") #'exwm-input-send-next-key)
         (define-key map (kbd "C-c f") #'exwm-layout-toggle-fullscreen)
         (define-key map (kbd "C-M-<delete>") #'faerryn/exwm-toggle-input)
         map))
     '(faerryn/exwm-input-global-keys
       (list (kbd "C-M-<delete>")))
     '(exwm-input-prefix-keys
       (list (kbd "C-c")
             (kbd "C-g")
             (kbd "C-h")
             (kbd "C-u")
             (kbd "C-x")
             (kbd "M-!")
             (kbd "M-&")
             (kbd "M-:")
             (kbd "M-x"))))
    (defun faerryn/exwm-rename-buffer ()
      (rename-buffer (concat "*EXWM " exwm-class-name "*") t))
    (add-hook 'exwm-update-class-hook #'faerryn/exwm-rename-buffer)
    (defun faerryn/exwm-restore-input (&rest ignored)
      (when (eq 'line-mode exwm--selected-input-mode)
        (exwm-input--grab-keyboard exwm--id)))
    (advice-add #'exwm-layout-set-fullscreen :after #'faerryn/exwm-restore-input)
    (defun faerryn/exwm-init-hook ()
      (add-hook 'faerryn/before-minibuffer-hook #'exwm-layout-unset-fullscreen)
      (add-hook 'window-state-change-hook #'exwm-layout-unset-fullscreen))
    (add-hook 'exwm-init-hook #'faerryn/exwm-init-hook)
    (defun faerryn/exwm-exit-hook ()
      (remove-hook 'faerryn/before-minibuffer-hook #'exwm-layout-unset-fullscreen)
      (remove-hook 'window-state-change-hook #'exwm-layout-unset-fullscreen))
    (add-hook 'exwm-exit-hook #'faerryn/exwm-exit-hook))
#+end_src
* Sundry
** Async Shell Command Buffer
Hide the buffer that `async-shell-command' produces.
#+begin_src emacs-lisp
  (custom-set-variables '(async-shell-command-buffer 'new-buffer))
  (add-to-list 'display-buffer-alist
               `(,(rx string-start "*Async Shell Command*")
                 display-buffer-no-window
                 allow-no-window))
#+end_src
** Compiler Explorer
RMSBolt is a compiler explorer inspired by [[https://godbolt.org][Godbolt]]. It allows a
programmer to see how individual lines of code are compiled.
#+begin_src emacs-lisp
  (straight-use-package 'rmsbolt)
  (autoload 'rmsbolt-mode "rmsbolt" "Toggle rmsbolt-mode." t)
  (with-eval-after-load "rmsbolt"
    (custom-set-variables
     '(rmsbolt-mode-map (let ((map (make-sparse-keymap)))
                          (define-key map (kbd "C-c b") #'rmsbolt-compile)
                          map))))
#+end_src
** Declutter File System
Disable autosaves, backups, and lockfiles for file system sanity.
#+begin_src emacs-lisp
  (custom-set-variables
   '(auto-save-default nil)
   '(make-backup-files nil)
   '(create-lockfiles nil))
#+end_src
** Eshell
Eshell is a portable, lispy shell in Emacs. This configures aliases
for eshell.
#+begin_src emacs-lisp
  (with-eval-after-load "em-alias"
    (eshell/alias "ls" "ls -FhvX --color=auto --group-directories-first $*")
    (eshell/alias "ll" "ls -g $*")
    (eshell/alias "la" "ll -A $*"))
#+end_src
** Follow Symlinks
#+begin_src emacs-lisp
  (custom-set-variables
   '(find-file-visit-truename t)
   '(vc-follow-symlinks t))
#+end_src
** Git Client
Magit is a very nice git client for Emacs. The killer feature (for me)
is staging small chunks at a time to split up big changes into
multiple commits.
#+begin_src emacs-lisp
  (straight-use-package 'magit)
  (custom-set-variables '(magit-define-global-key-bindings nil))
  (autoload 'magit-status "magit"
    "Show the status of the current Git repository in a buffer." t)
  (define-key (current-global-map) (kbd "C-c g") #'magit-status)
#+end_src
** Vterm
Vterm is an efficient replacement for emacs' built-in `term'.
#+begin_src emacs-lisp
  (straight-use-package 'vterm)
  (custom-set-variables '(vterm-environment '("COLORTERM=truecolor")))
  (autoload 'vterm "vterm" "Create an interactive Vterm buffer." t)
#+end_src
